Reachable Roads

#include<bits/stdc++.h>

using namespace std;

int parents[1001];

int Find(int x){
  if(x==parents[x]) return x;
  else return parents[ x ] = Find( parents[ x ] );
}

// int required;

void Union( int x , int y){
  // required--;
  int xRoot = Find( x );
  int yRoot = Find( y );
  parents[ xRoot ] = yRoot;
}

int main(){

  int n;
  cin>>n;
  while(n--){
    int m, r;
    cin>>m;
    // required=m;
    for (int i = 0; i < m; i++){
      parents[i]=i;
    }
    cin>>r;
    for (int i = 0; i < r; i++){
      int a, b;
      cin>>a>>b;
      Union(a,b);
    }
    cout<<"[";
    for (int i = 0; i < m; i++){
      cout<<Find(i)<<" ";
    }
    cout<<"]"<<endl;
      
    // cout<<required-1<<endl;
      
  }
  return 0;
}




Sailing Friends

#include<bits/stdc++.h>

using namespace std;

vector<int> people[100100];
bool vis[100100];
bool ye[100100];
int yes = 0;

void check(int x){
  if(vis[x]) return;
  if(ye[x]) cout<<"*";
  else cout<<"-";
  vis[x] = true;
  for (int i = 0; i < people[x].size(); i++){
    check(people[x][i]);
  }
}

int main(){
  
  int n, b, m;
  cin>>n>>b>>m;
  memset(vis,false,sizeof(vis));
  memset(ye,false,sizeof(ye));
  for (int i = 1; i <= n; i++){people[i].clear();}
  for (int i = 0; i < b; i++){
    int a;
    cin>>a;
    ye[a]=true;
  }
  for (int i = 0; i < m; i++){
    int a, b;
    cin>>a>>b;
    people[a].push_back(b);
    people[b].push_back(a);
  }
  int g=0;
  cout<<endl;
  for (int i = 1; i <= n; i++){
    if(!vis[i]){
      g++;
      check(i);
      cout<<endl;
    };
  }
  cout<<g<<endl;

  return 0;
}

=========================================================

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

vector<int> parent;
vector<int> rankArr;  // Cambiado de rank a rankArr

// Inicializar Union-Find
void initialize(int n) {
    parent.resize(n);
    rankArr.resize(n, 0);
    for (int i = 0; i < n; ++i) {
        parent[i] = i;
    }
}

// Encontrar el representante de un conjunto
int find(int u) {
    if (parent[u] != u) {
        parent[u] = find(parent[u]);
    }
    return parent[u];
}

// Unir dos conjuntos
void unite(int u, int v) {
    int rootU = find(u);
    int rootV = find(v);
    if (rootU != rootV) {
        if (rankArr[rootU] > rankArr[rootV]) {
            parent[rootV] = rootU;
        } else if (rankArr[rootU] < rankArr[rootV]) {
            parent[rootU] = rootV;
        } else {
            parent[rootV] = rootU;
            ++rankArr[rootU];
        }
    }
}

int main() {
    int N, B, M;
    cin >> N >> B >> M;

    vector<bool> hasBoat(N, false);
    for (int i = 0; i < B; ++i) {
        int boatOwner;
        cin >> boatOwner;
        hasBoat[boatOwner - 1] = true;
    }

    initialize(N);
    for (int i = 0; i < M; ++i) {
        int a, b;
        cin >> a >> b;
        unite(a - 1, b - 1);
    }

    vector<bool> componentHasBoat(N, false);
    for (int i = 0; i < N; ++i) {
        int root = find(i);
        if (hasBoat[i]) {
            componentHasBoat[root] = true;
        }
    }

    int neededBoats = 0;
    for (int i = 0; i < N; ++i) {
        int root = find(i);
        if (!componentHasBoat[root]) {
            ++neededBoats;
            componentHasBoat[root] = true;
        }
    }

    cout << neededBoats << endl;

    return 0;
}


=========================================================

#include<bits/stdc++.h>

using namespace std;

int boats[100100];
bool yes[100100];
vector<int> sisi;

int groups;

int Find(int x){
  if(x==boats[x]) {
    return x;
  }
  else return boats[x]=Find(boats[x]);
}

void St(int x){
  if(x==boats[x]) {
    yes[x]=true;
  }
  else St(boats[x]);
}

void Union(int a, int b){
  groups--;
  int ra = Find(a);
  int rb= Find(b);
  boats[rb] = ra;
}

int main(){

  memset(boats,0,sizeof(boats));
  memset(yes,false,sizeof(yes));
  int n, b, m;
  cin>>n>>b>>m;
  groups=n;
  for (int i = 1; i <= n; i++){boats[i]=i;}

  for (int i = 0; i < b; i++){
    int a;
    cin>>a;
    sisi.push_back(a);
  }

  for (int i = 0; i < m; i++){
    int a, b;
    cin>>a>>b;
    Union(a,b);
  }

  for (int i = 0; i < sisi.size(); i++){
    St(sisi[i]);
  }
  
  int aux=0, wo=0;
  for (int i = 1; i <= n; i++){
    if(yes[Find(i)] && aux!=Find(i)){
      aux=Find(i);
      wo++;
    }
  }
  cout<<groups-wo<<endl;

  return 0;
}